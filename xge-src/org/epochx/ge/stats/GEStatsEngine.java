/*
 * Copyright 2007-2010 Tom Castle & Lawrence Beadle
 * Licensed under GNU General Public License
 * 
 * This file is part of EpochX: genetic programming software for research
 * 
 * EpochX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * EpochX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with EpochX. If not, see <http://www.gnu.org/licenses/>.
 * 
 * The latest version is available from: http:/www.epochx.org
 */
package org.epochx.ge.stats;

import static org.epochx.ge.stats.GEStatField.*;
import static org.epochx.stats.StatField.GEN_POPULATION;

import java.util.List;

import org.apache.commons.lang.math.NumberUtils;
import org.epochx.ge.model.GEModel;
import org.epochx.ge.representation.GECandidateProgram;
import org.epochx.stats.*;

/**
 * Generates statistics about evolutionary events within XGE.
 * 
 * <p>
 * A <code>CommonStatsEngine</code> is plugged into <code>StatsManager</code>
 * instances to generate those statistics that are requested from the
 * <code>StatsManager</code>. When a statistic is calculated it may be dependant
 * upon other statistic fields which will be requested from the <code>
 * StatsManager</code> and may in turn be generated by this class.
 */
public class GEStatsEngine extends CommonStatsEngine {

	// The controlling model.
	private final GEModel model;

	/**
	 * Constructs a <code>GEStatsEngine</code> to generate statistics on
	 * request.
	 * 
	 * @param model the Model which provides access to the <code>StatsManager
	 * </code>.
	 */
	public GEStatsEngine(final GEModel model) {
		super(model);

		this.model = model;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Object getStat(final Object field) {
		// If not a GEStatField then we don't support it here.
		if (!(field instanceof GEStatField)) {
			return null;
		}
		
		Object value = null;

		if (field == GEN_DEPTHS) {
			value = getGenDepths();
		} else if (field == GEN_DEPTH_MIN) {
			value = getGenDepthMin();
		} else if (field == GEN_DEPTH_MAX) {
			value = getGenDepthMax();
		} else if (field == GEN_DEPTH_AVE) {
			value = getGenDepthAve();
		} else if (field == GEN_DEPTH_STDEV) {
			value = getGenDepthStdev();
		} else if (field == GEN_LENGTHS) {
			value = getGenLengths();
		} else if (field == GEN_LENGTH_MIN) {
			value = getGenLengthMin();
		} else if (field == GEN_LENGTH_MAX) {
			value = getGenLengthMax();
		} else if (field == GEN_LENGTH_AVE) {
			value = getGenLengthAve();
		} else if (field == GEN_LENGTH_STDEV) {
			value = getGenLengthStdev();
		}

		return value;
	}

	/*
	 * Calculate and return the GEN_DEPTHS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenDepths() {
		int[] depths = null;

		// Request the population from the stats manager.
		final List<GECandidateProgram> pop = (List<GECandidateProgram>) model
				.getStatsManager().getStat(GEN_POPULATION);

		// Get the depths of each program.
		if (pop != null) {
			depths = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				depths[i] = pop.get(i).getParseTreeDepth();
			}
		}

		return depths;
	}

	/*
	 * Calculate and return the GEN_DEPTH_MIN statistic.
	 */
	private Object getGenDepthMin() {
		Integer minDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getStat(
				GEN_DEPTHS);

		// Calculate the minimum depth.
		if (depths != null) {
			minDepth = NumberUtils.min(depths);
		}

		return minDepth;
	}

	/*
	 * Calculate and return the GEN_DEPTH_MAX statistic.
	 */
	private Object getGenDepthMax() {
		Integer maxDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getStat(
				GEN_DEPTHS);

		// Calculate the maximum depth.
		if (depths != null) {
			maxDepth = NumberUtils.max(depths);
		}

		return maxDepth;
	}

	/*
	 * Calculate and return the GEN_DEPTH_AVE statistic.
	 */
	private Object getGenDepthAve() {
		Double aveDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getStat(
				GEN_DEPTHS);

		// Calculate the average depth.
		if (depths != null) {
			aveDepth = StatsUtils.ave(depths);
		}

		return aveDepth;
	}

	/*
	 * Calculate and return the GEN_DEPTH_STDEV statistic.
	 */
	private Object getGenDepthStdev() {
		Double stdevDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getStat(
				GEN_DEPTHS);

		// Calculate the standard deviation of the depths.
		if (depths != null) {
			stdevDepth = StatsUtils.stdev(depths);
		}

		return stdevDepth;
	}

	/*
	 * Calculate and return the GEN_LENGTHS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenLengths() {
		int[] lengths = null;

		// Request the population from the stats manager.
		final List<GECandidateProgram> pop = (List<GECandidateProgram>) model
				.getStatsManager().getStat(GEN_POPULATION);

		// Get the lengths of each program.
		if (pop != null) {
			lengths = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				lengths[i] = pop.get(i).getNoCodons();
			}
		}

		return lengths;
	}

	/*
	 * Calculate and return the GEN_LENGTH_MIN statistic.
	 */
	private Object getGenLengthMin() {
		Integer minLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getStat(GEN_LENGTHS);

		// Calculate the minimum length.
		if (lengths != null) {
			minLength = NumberUtils.min(lengths);
		}

		return minLength;
	}

	/*
	 * Calculate and return the GEN_LENGTH_MAX statistic.
	 */
	private Object getGenLengthMax() {
		Integer maxLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getStat(GEN_LENGTHS);

		// Calculate the maximum length.
		if (lengths != null) {
			maxLength = NumberUtils.max(lengths);
		}

		return maxLength;
	}

	/*
	 * Calculate and return the GEN_LENGTH_AVE statistic.
	 */
	private Object getGenLengthAve() {
		Double aveLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getStat(GEN_LENGTHS);

		// Calculate the average length.
		if (lengths != null) {
			aveLength = StatsUtils.ave(lengths);
		}

		return aveLength;
	}

	/*
	 * Calculate and return the GEN_LENGTH_STDEV statistic.
	 */
	private Object getGenLengthStdev() {
		Double stdevLength = null;

		// Request the population depths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getStat(GEN_LENGTHS);

		// Calculate the standard deviation of the lengths.
		if (lengths != null) {
			stdevLength = StatsUtils.stdev(lengths);
		}

		return stdevLength;
	}
}
