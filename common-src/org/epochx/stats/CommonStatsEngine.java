/*
 * Copyright 2007-2010 Tom Castle & Lawrence Beadle
 * Licensed under GNU General Public License
 * 
 * This file is part of EpochX: genetic programming software for research
 * 
 * EpochX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * EpochX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with EpochX. If not, see <http://www.gnu.org/licenses/>.
 * 
 * The latest version is available from: http:/www.epochx.org
 */
package org.epochx.stats;

import static org.epochx.stats.StatField.*;

import java.util.List;

import org.apache.commons.lang.math.NumberUtils;
import org.epochx.core.Model;
import org.epochx.representation.CandidateProgram;

/**
 * Generates statistics about evolutionary events.
 * 
 * <p>
 * A <code>CommonStatsEngine</code> is plugged into <code>StatsManager</code>
 * instances to generate those statistics that are requested from the
 * <code>StatsManager</code>. When a statistic is calculated it may be dependant
 * upon other statistic fields which will be requested from the <code>
 * StatsManager</code> and may in turn be generated by this class.
 */
public class CommonStatsEngine implements StatsEngine {

	// The controlling model.
	private final Model model;
	
	/**
	 * Constructs a <code>CommonStatsEngine</code> to generate statistics on request.
	 * 
	 * @param model the Model which provides access to the <code>StatsManager
	 * </code>.
	 */
	public CommonStatsEngine(final Model model) {
		this.model = model;
	}
	
	/**
	 * Calculates and returns the generation statistic associated with the given
	 * field provided as an argument.
	 * 
	 * @param field an identifying string for the generation statistic being
	 *        requested.
	 * @return an <code>Object</code> which is the statistic requested or
	 *         <code>null</code> if the statistic cannot be generated by this
	 *         stats
	 *         engine.
	 */
	@Override
	public Object getStat(final Object field) {
		// If not a StatField then we don't support it here.
		if (!(field instanceof StatField)) {
			return null;
		}
		
		Object value = null;

		if (field == GEN_FITNESSES) {
			value = getGenFitnesses();
		} else if (field == GEN_FITNESS_MIN) {
			value = getGenFitnessMin();
		} else if (field == GEN_FITNESS_MAX) {
			value = getGenFitnessMax();
		} else if (field == GEN_FITNESS_AVE) {
			value = getGenFitnessAve();
		} else if (field == GEN_FITNESS_STDEV) {
			value = getGenFitnessStdev();
		} else if (field == GEN_FITNESS_MEDIAN) {
			value = getGenFitnessMedian();
		} else if (field == GEN_FITNESS_CI95) {
			value = getGenFitnessCI95();
		} else if (field == GEN_FITTEST_PROGRAM) {
			value = getGenBestProgram();
		}

		return value;
	}

	/*
	 * Calculate and return the GEN_FITNESSES statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenFitnesses() {
		double[] fitnesses = null;

		// Request the population from the stats manager.
		final List<CandidateProgram> pop = (List<CandidateProgram>) model
				.getStatsManager().getStat(GEN_POPULATION);

		// Get the fitnesses of each program.
		if (pop != null) {
			fitnesses = new double[pop.size()];

			for (int i = 0; i < fitnesses.length; i++) {
				fitnesses[i] = pop.get(i).getFitness();
			}
		}

		return fitnesses;
	}

	/*
	 * Calculate and return the GEN_FITNESS_MIN statistic.
	 */
	private Object getGenFitnessMin() {
		Double minFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the minimum fitness value.
		if (fitnesses != null) {
			minFitness = NumberUtils.min(fitnesses);
		}

		return minFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_MAX statistic.
	 */
	private Object getGenFitnessMax() {
		Double maxFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the maximum fitness value.
		if (fitnesses != null) {
			maxFitness = NumberUtils.max(fitnesses);
		}

		return maxFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_AVE statistic.
	 */
	private Object getGenFitnessAve() {
		Double aveFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the average fitness value.
		if (fitnesses != null) {
			aveFitness = StatsUtils.ave(fitnesses);
		}

		return aveFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_STDEV statistic.
	 */
	private Object getGenFitnessStdev() {
		Double stdevFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);
		final double averageFitness = (Double) model.getStatsManager()
				.getStat(GEN_FITNESS_AVE);

		// Calculate the standard deviation of the fitness values.
		if (fitnesses != null) {
			stdevFitness = StatsUtils.stdev(fitnesses, averageFitness);
		}

		return stdevFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_MEDIAN statistic.
	 */
	private Object getGenFitnessMedian() {
		Double medianFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the median of the fitness values.
		if (fitnesses != null) {
			medianFitness = StatsUtils.median(fitnesses);
		}

		return medianFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_CI95 statistic.
	 */
	private Object getGenFitnessCI95() {
		Double ci95Fitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES);
		final double stdev = (Double) model.getStatsManager().getStat(GEN_FITNESS_STDEV);

		// Calculate the 95% confidence interval from the mean of the fitness
		// values.
		if (fitnesses != null) {
			ci95Fitness = StatsUtils.ci95(fitnesses, stdev);
		}

		return ci95Fitness;
	}

	/*
	 * Calculate and return the GEN_FITTEST_PROGRAM statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenBestProgram() {
		CandidateProgram bestProgram = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES);
		final List<CandidateProgram> pop = (List<CandidateProgram>) model.getStatsManager().getStat(GEN_POPULATION);

		// Retrieve the program with the minimum fitness value.
		if (fitnesses != null) {
			final int bestProgramIndex = StatsUtils.minIndex(fitnesses);

			bestProgram = pop.get(bestProgramIndex);
		}

		return bestProgram;
	}
}
