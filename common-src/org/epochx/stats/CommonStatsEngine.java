/*
 * Copyright 2007-2010 Tom Castle & Lawrence Beadle
 * Licensed under GNU General Public License
 * 
 * This file is part of EpochX: genetic programming software for research
 * 
 * EpochX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * EpochX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with EpochX. If not, see <http://www.gnu.org/licenses/>.
 * 
 * The latest version is available from: http:/www.epochx.org
 */
package org.epochx.stats;

import static org.epochx.stats.StatField.*;

import java.util.*;

import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.math.NumberUtils;
import org.epochx.core.Model;
import org.epochx.representation.CandidateProgram;

/**
 * Generates statistics about evolutionary events.
 * 
 * <p>
 * A <code>CommonStatsEngine</code> is plugged into <code>StatsManager</code>
 * instances to generate those statistics that are requested from the
 * <code>StatsManager</code>. When a statistic is calculated it may be dependant
 * upon other statistic fields which will be requested from the <code>
 * StatsManager</code> and may in turn be generated by this class.
 */
public class CommonStatsEngine implements StatsEngine {

	// The controlling model.
	private final Model model;
	
	/**
	 * Constructs a <code>CommonStatsEngine</code> to generate statistics on request.
	 * 
	 * @param model the Model which provides access to the <code>StatsManager
	 * </code>.
	 */
	public CommonStatsEngine(final Model model) {
		this.model = model;
	}
	
	/**
	 * Calculates and returns the generation statistic associated with the given
	 * field provided as an argument.
	 * 
	 * @param field an identifying string for the generation statistic being
	 *        requested.
	 * @return an <code>Object</code> which is the statistic requested or
	 *         <code>null</code> if the statistic cannot be generated by this
	 *         stats
	 *         engine.
	 */
	@Override
	public Object getStat(final Object field) {
		// If not a StatField then we don't support it here.
		if (!(field instanceof StatField)) {
			return null;
		}
		
		Object value = null;

		if (field == GEN_FITNESSES) {
			value = getGenFitnesses();
		} else if (field == GEN_FITNESS_MIN) {
			value = getGenFitnessMin();
		} else if (field == GEN_FITNESS_MAX) {
			value = getGenFitnessMax();
		} else if (field == GEN_FITNESS_AVE) {
			value = getGenFitnessAve();
		} else if (field == GEN_FITNESS_STDEV) {
			value = getGenFitnessStdev();
		} else if (field == GEN_FITNESS_MEDIAN) {
			value = getGenFitnessMedian();
		} else if (field == GEN_FITNESS_CI95) {
			value = getGenFitnessCI95();
		} else if (field == GEN_FITTEST_PROGRAM) {
			value = getGenBestProgram();
		} else if (field == GEN_FITTEST_PROGRAMS) {
			value = getGenBestPrograms();
		} else if (field == GEN_POP_SORTED) {
			value = getGenPopSorted();
		} else if (field == GEN_POP_SORTED_DESC) {
			value = getGenPopSortedDesc();
		} else if (field == GEN_FITNESSES_SORTED) {
			value = getGenFitnessesSorted();
		} else if (field == GEN_FITNESSES_SORTED_DESC) {
			value = getGenFitnessesSortedDesc();
		} else if (field == MUT_PARENT_FITNESS) {
			value = getMutParentFitness();
		} else if (field == MUT_CHILD_FITNESS) {
			value = getMutChildFitness();
		} else if (field == MUT_FITNESS_CHANGE) {
			value = getMutFitnessChange();
		} else if (field == XO_PARENT_FITNESSES) {
			value = getXOParentFitnesses();
		} else if (field == XO_CHILD_FITNESSES) {
			value = getXOChildFitnesses();
		} else if (field == XO_PARENTS_FITNESS_AVE) {
			value = getXOParentsFitnessAve();
		} else if (field == XO_CHILDREN_FITNESS_AVE) {
			value = getXOChildrenFitnessAve();
		} else if (field == XO_FITNESS_AVE_CHANGE) {
			value = getXOFitnessAveChange();
		} else if (field == POOL_SIZE) {
			value = getPoolSize();
		} else if (field == POOL_FITNESSES) {
			value = getPoolFitnesses();
		} else if (field == POOL_FITNESS_MIN) {
			value = getPoolFitnessMin();
		} else if (field == POOL_FITNESS_MAX) {
			value = getPoolFitnessMax();
		} else if (field == POOL_FITNESS_AVE) {
			value = getPoolFitnessAve();
		} else if (field == POOL_FITNESS_STDEV) {
			value = getPoolFitnessStdev();
		} else if (field == POOL_FITNESS_MEDIAN) {
			value = getPoolFitnessMedian();
		} else if (field == POOL_FITNESS_CI95) {
			value = getPoolFitnessCI95();
		} else if (field == POOL_FITTEST_PROGRAM) {
			value = getPoolBestProgram();
		} else if (field == POOL_FITTEST_PROGRAMS) {
			value = getPoolBestPrograms();
		} else if (field == ELITE_FITNESSES) {
			value = getEliteFitnesses();
		} else if (field == ELITE_FITNESS_MIN) {
			value = getEliteFitnessMin();
		} else if (field == ELITE_FITNESS_MAX) {
			value = getEliteFitnessMax();
		} else if (field == ELITE_FITNESS_AVE) {
			value = getEliteFitnessAve();
		} else if (field == ELITE_FITNESS_STDEV) {
			value = getEliteFitnessStdev();
		} else if (field == ELITE_FITNESS_MEDIAN) {
			value = getEliteFitnessMedian();
		} else if (field == ELITE_FITNESS_CI95) {
			value = getEliteFitnessCI95();
		} else if (field == ELITE_SIZE) {
			value = getEliteSize();
		}

		return value;
	}

	/*
	 * Calculate and return the GEN_FITNESSES statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenFitnesses() {
		double[] fitnesses = null;

		// Request the population from the stats manager.
		final List<CandidateProgram> pop = (List<CandidateProgram>) model
				.getStatsManager().getStat(GEN_POP);

		// Get the fitnesses of each program.
		if (pop != null) {
			fitnesses = new double[pop.size()];

			for (int i = 0; i < fitnesses.length; i++) {
				fitnesses[i] = pop.get(i).getFitness();
			}
		}

		return fitnesses;
	}

	/*
	 * Calculate and return the GEN_FITNESS_MIN statistic.
	 */
	private Object getGenFitnessMin() {
		Double minFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the minimum fitness value.
		if (fitnesses != null) {
			minFitness = NumberUtils.min(fitnesses);
		}

		return minFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_MAX statistic.
	 */
	private Object getGenFitnessMax() {
		Double maxFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the maximum fitness value.
		if (fitnesses != null) {
			maxFitness = NumberUtils.max(fitnesses);
		}

		return maxFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_AVE statistic.
	 */
	private Object getGenFitnessAve() {
		Double aveFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the average fitness value.
		if (fitnesses != null) {
			aveFitness = StatsUtils.ave(fitnesses);
		}

		return aveFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_STDEV statistic.
	 */
	private Object getGenFitnessStdev() {
		Double stdevFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);
		final double averageFitness = (Double) model.getStatsManager()
				.getStat(GEN_FITNESS_AVE);

		// Calculate the standard deviation of the fitness values.
		if (fitnesses != null) {
			stdevFitness = StatsUtils.stdev(fitnesses, averageFitness);
		}

		return stdevFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_MEDIAN statistic.
	 */
	private Object getGenFitnessMedian() {
		Double medianFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(GEN_FITNESSES);

		// Calculate the median of the fitness values.
		if (fitnesses != null) {
			medianFitness = StatsUtils.median(fitnesses);
		}

		return medianFitness;
	}

	/*
	 * Calculate and return the GEN_FITNESS_CI95 statistic.
	 */
	private Object getGenFitnessCI95() {
		Double ci95Fitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES);
		final double stdev = (Double) model.getStatsManager().getStat(GEN_FITNESS_STDEV);

		// Calculate the 95% confidence interval from the mean of the fitness
		// values.
		if (fitnesses != null) {
			ci95Fitness = StatsUtils.ci95(fitnesses, stdev);
		}

		return ci95Fitness;
	}

	/*
	 * Calculate and return the GEN_FITTEST_PROGRAM statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenBestProgram() {
		CandidateProgram bestProgram = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES);
		final List<CandidateProgram> pop = (List<CandidateProgram>) model.getStatsManager().getStat(GEN_POP);

		// Retrieve the program with the minimum fitness value.
		if (fitnesses != null) {
			final int bestProgramIndex = StatsUtils.minIndex(fitnesses);

			bestProgram = pop.get(bestProgramIndex);
		}

		return bestProgram;
	}
	
	/*
	 * Calculate and return the GEN_FITTEST_PROGRAMS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenBestPrograms() {
		List<CandidateProgram> bestPrograms = new ArrayList<CandidateProgram>();

		// Request the population fitnesses from the stats manager.
		final Double minFitness = (Double) model.getStatsManager().getStat(GEN_FITNESS_MIN);
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES);
		final List<CandidateProgram> pop = (List<CandidateProgram>) model.getStatsManager().getStat(GEN_POP);

		// Retrieve all the programs with the minimum fitness value.
		if (minFitness != null && fitnesses != null) {
			for (int i=0; i<fitnesses.length; i++) {
				double fitness = fitnesses[i];
				if (fitness == minFitness.doubleValue()) {
					bestPrograms.add(pop.get(i));
				}
			}
		}

		return bestPrograms;
	}
	
	/*
	 * Calculate and return the GEN_POP_SORTED statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenPopSorted() {
		List<CandidateProgram> sortedPop = null;
		
		// Request the population from the stats manager.
		final List<CandidateProgram> pop = (List<CandidateProgram>) model.getStatsManager().getStat(GEN_POP);
		
		if (pop != null) {
			// Create a copy of the population to be sorted.
			sortedPop = new ArrayList<CandidateProgram>(pop);
		
			// Sort the population.
			Collections.sort(sortedPop);
		}

		return sortedPop;
	}
	
	/*
	 * Calculate and return the GEN_POP_SORTED_DESC statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenPopSortedDesc() {
		List<CandidateProgram> sortedPop = null;
		
		// Request the population from the stats manager.
		final List<CandidateProgram> pop = (List<CandidateProgram>) model.getStatsManager().getStat(GEN_POP);
		
		if (pop != null) {
			// Create a copy of the population to be sorted.
			sortedPop = new ArrayList<CandidateProgram>(pop);
			
			// Sort the population.
			Collections.sort(sortedPop, Collections.reverseOrder());
		}

		return sortedPop;
	}
	
	/*
	 * Calculate and return the GEN_FITNESSES_SORTED statistic.
	 */
	private Object getGenFitnessesSorted() {
		double[] sortedFitnesses = null;
		
		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES);
		
		if (fitnesses != null) {
			// Create a copy of the fitnesses.
			sortedFitnesses = fitnesses.clone();
			
			// Sort the fitnesses.
			Arrays.sort(sortedFitnesses);
		}

		return sortedFitnesses;
	}
	
	/*
	 * Calculate and return the GEN_FITNESSES_SORTED_DESC statistic.
	 */
	private Object getGenFitnessesSortedDesc() {
		double[] sortedFitnessesDesc = null;
		
		// Request the ascending sorted fitnesses from the stats manager.
		final double[] sortedFitnesses = (double[]) model.getStatsManager().getStat(GEN_FITNESSES_SORTED);

		if (sortedFitnesses != null) {
			// Create a copy of the sorted fitnesses.
			sortedFitnessesDesc = sortedFitnesses.clone();
			
			// Reverse the order of the sorted fitnesses.
			ArrayUtils.reverse(sortedFitnessesDesc);
		}

		return sortedFitnessesDesc;
	}
	
	/*
	 * Calculate and return the MUT_PARENT_FITNESS statistic.
	 */
	private Object getMutParentFitness() {
		Double fitness = null;
		
		// Request the parent from the stats manager.
		final CandidateProgram parent = (CandidateProgram) model.getStatsManager().getStat(MUT_PARENT);

		if (parent != null) {
			// Get the program's fitness.
			fitness = parent.getFitness();
		}

		return fitness;
	}
	
	/*
	 * Calculate and return the MUT_CHILD_FITNESS statistic.
	 */
	private Object getMutChildFitness() {
		Double fitness = null;
		
		// Request the child from the stats manager.
		final CandidateProgram child = (CandidateProgram) model.getStatsManager().getStat(MUT_CHILD);

		if (child != null) {
			// Get the program's fitness.
			fitness = child.getFitness();
		}

		return fitness;
	}
	
	/*
	 * Calculate and return the MUT_FITNESS_CHANGE statistic.
	 */
	private Object getMutFitnessChange() {
		Double fitnessChange = null;
		
		// Request the fitnesses from the stats manager.
		final Double fitnessBefore = (Double) model.getStatsManager().getStat(MUT_PARENT_FITNESS);
		final Double fitnessAfter = (Double) model.getStatsManager().getStat(MUT_CHILD_FITNESS);
		
		if (fitnessBefore != null && fitnessAfter != null) {
			// Calculate the fitness change.
			fitnessChange = fitnessAfter.doubleValue() - fitnessBefore.doubleValue();
		}

		return fitnessChange;
	}
	
	/*
	 * Calculate and return the XO_PARENT_FITNESSES statistic.
	 */
	private Object getXOParentFitnesses() {
		double[] fitnesses = null;
		
		// Request the parents from the stats manager.
		final CandidateProgram[] parents = (CandidateProgram[]) model.getStatsManager().getStat(XO_PARENTS);
		
		if (parents != null) {
			fitnesses = new double[parents.length];
			
			for (int i=0; i<parents.length; i++) {
				// Calculate the fitness change.
				fitnesses[i] = parents[i].getFitness();
			}
		}

		return fitnesses;
	}
	
	/*
	 * Calculate and return the XO_CHILD_FITNESSES statistic.
	 */
	private Object getXOChildFitnesses() {
		double[] fitnesses = null;
		
		// Request the children from the stats manager.
		final CandidateProgram[] children = (CandidateProgram[]) model.getStatsManager().getStat(XO_CHILDREN);
		
		if (children != null) {
			fitnesses = new double[children.length];
			
			for (int i=0; i<children.length; i++) {
				// Calculate the fitness change.
				fitnesses[i] = children[i].getFitness();
			}
		}

		return fitnesses;
	}
	
	/*
	 * Calculate and return the XO_PARENTS_FITNESS_AVE statistic.
	 */
	private Object getXOParentsFitnessAve() {
		Double aveFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(XO_PARENT_FITNESSES);

		// Calculate the average fitness value.
		if (fitnesses != null) {
			aveFitness = StatsUtils.ave(fitnesses);
		}

		return aveFitness;
	}
	
	/*
	 * Calculate and return the XO_CHILDREN_FITNESS_AVE statistic.
	 */
	private Object getXOChildrenFitnessAve() {
		Double aveFitness = null;

		// Request the population fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(XO_CHILD_FITNESSES);

		// Calculate the average fitness value.
		if (fitnesses != null) {
			aveFitness = StatsUtils.ave(fitnesses);
		}

		return aveFitness;
	}
	
	/*
	 * Calculate and return the XO_FITNESS_AVE_CHANGE statistic.
	 */
	private Object getXOFitnessAveChange() {
		Double fitnessChange = null;
		
		// Request the parent from the stats manager.
		final Double aveFitnessBefore = (Double) model.getStatsManager().getStat(XO_PARENTS_FITNESS_AVE);
		final Double aveFitnessAfter = (Double) model.getStatsManager().getStat(XO_CHILDREN_FITNESS_AVE);
		
		if (aveFitnessBefore != null && aveFitnessAfter != null) {
			// Calculate the fitness change.
			fitnessChange = aveFitnessAfter.doubleValue() - aveFitnessBefore.doubleValue();
		}

		return fitnessChange;
	}
	
	/*
	 * Calculate and return the POOL_SIZE statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getPoolSize() {
		Integer poolSize = null;
		
		// Request the pool from the stats manager.
		final List<CandidateProgram> pool = (List<CandidateProgram>) model.getStatsManager().getStat(XO_PARENTS_FITNESS_AVE);
		
		if (pool != null) {
			// Calculate the fitness change.
			poolSize = pool.size();
		}

		return poolSize;
	}
	
	/*
	 * Calculate and return the POOL_FITNESSES statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getPoolFitnesses() {
		double[] fitnesses = null;

		// Request the pool from the stats manager.
		final List<CandidateProgram> pop = (List<CandidateProgram>) model
				.getStatsManager().getStat(POOL_PROGRAMS);

		// Get the fitnesses of each program.
		if (pop != null) {
			fitnesses = new double[pop.size()];

			for (int i = 0; i < fitnesses.length; i++) {
				fitnesses[i] = pop.get(i).getFitness();
			}
		}

		return fitnesses;
	}
	
	/*
	 * Calculate and return the POOL_FITNESS_MIN statistic.
	 */
	private Object getPoolFitnessMin() {
		Double minFitness = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(POOL_FITNESSES);

		// Calculate the minimum fitness value.
		if (fitnesses != null) {
			minFitness = NumberUtils.min(fitnesses);
		}

		return minFitness;
	}

	/*
	 * Calculate and return the POOL_FITNESS_MAX statistic.
	 */
	private Object getPoolFitnessMax() {
		Double maxFitness = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(POOL_FITNESSES);

		// Calculate the maximum fitness value.
		if (fitnesses != null) {
			maxFitness = NumberUtils.max(fitnesses);
		}

		return maxFitness;
	}

	/*
	 * Calculate and return the POOL_FITNESS_AVE statistic.
	 */
	private Object getPoolFitnessAve() {
		Double aveFitness = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(POOL_FITNESSES);

		// Calculate the average fitness value.
		if (fitnesses != null) {
			aveFitness = StatsUtils.ave(fitnesses);
		}

		return aveFitness;
	}

	/*
	 * Calculate and return the POOL_FITNESS_STDEV statistic.
	 */
	private Object getPoolFitnessStdev() {
		Double stdevFitness = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(POOL_FITNESSES);
		final double averageFitness = (Double) model.getStatsManager()
				.getStat(POOL_FITNESS_AVE);

		// Calculate the standard deviation of the fitness values.
		if (fitnesses != null) {
			stdevFitness = StatsUtils.stdev(fitnesses, averageFitness);
		}

		return stdevFitness;
	}

	/*
	 * Calculate and return the POOL_FITNESS_MEDIAN statistic.
	 */
	private Object getPoolFitnessMedian() {
		Double medianFitness = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(POOL_FITNESSES);

		// Calculate the median of the fitness values.
		if (fitnesses != null) {
			medianFitness = StatsUtils.median(fitnesses);
		}

		return medianFitness;
	}

	/*
	 * Calculate and return the POOL_FITNESS_CI95 statistic.
	 */
	private Object getPoolFitnessCI95() {
		Double ci95Fitness = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(POOL_FITNESSES);
		final double stdev = (Double) model.getStatsManager().getStat(POOL_FITNESS_STDEV);

		// Calculate the 95% confidence interval from the mean of the fitness
		// values.
		if (fitnesses != null) {
			ci95Fitness = StatsUtils.ci95(fitnesses, stdev);
		}

		return ci95Fitness;
	}

	/*
	 * Calculate and return the POOL_FITTEST_PROGRAM statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getPoolBestProgram() {
		CandidateProgram bestProgram = null;

		// Request the pool fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(POOL_FITNESSES);
		final List<CandidateProgram> pool = (List<CandidateProgram>) model.getStatsManager().getStat(POOL_PROGRAMS);

		// Retrieve the program with the minimum fitness value.
		if (fitnesses != null) {
			final int bestProgramIndex = StatsUtils.minIndex(fitnesses);

			bestProgram = pool.get(bestProgramIndex);
		}

		return bestProgram;
	}
	
	/*
	 * Calculate and return the POOL_FITTEST_PROGRAMS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getPoolBestPrograms() {
		List<CandidateProgram> bestPrograms = new ArrayList<CandidateProgram>();

		// Request the pool fitnesses from the stats manager.
		final Double minFitness = (Double) model.getStatsManager().getStat(POOL_FITNESS_MIN);
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(POOL_FITNESSES);
		final List<CandidateProgram> pool = (List<CandidateProgram>) model.getStatsManager().getStat(POOL_PROGRAMS);

		// Retrieve all the programs with the minimum fitness value.
		if (minFitness != null && fitnesses != null) {
			for (int i=0; i<fitnesses.length; i++) {
				double fitness = fitnesses[i];
				if (fitness == minFitness.doubleValue()) {
					bestPrograms.add(pool.get(i));
				}
			}
		}

		return bestPrograms;
	}
	
	/*
	 * Calculate and return the ELITE_SIZE statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getEliteSize() {
		Integer eliteSize = null;
		
		// Request the pool from the stats manager.
		final List<CandidateProgram> elites = (List<CandidateProgram>) model.getStatsManager().getStat(ELITE_PROGRAMS);
		
		if (elites != null) {
			// Calculate the fitness change.
			eliteSize = elites.size();
		}

		return eliteSize;
	}
	
	/*
	 * Calculate and return the ELITE_FITNESSES statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getEliteFitnesses() {
		double[] fitnesses = null;

		// Request the elites from the stats manager.
		final List<CandidateProgram> elites = (List<CandidateProgram>) model
				.getStatsManager().getStat(ELITE_PROGRAMS);

		// Get the fitnesses of each program.
		if (elites != null) {
			fitnesses = new double[elites.size()];

			for (int i = 0; i < fitnesses.length; i++) {
				fitnesses[i] = elites.get(i).getFitness();
			}
		}

		return fitnesses;
	}
	
	/*
	 * Calculate and return the ELITE_FITNESS_MIN statistic.
	 */
	private Object getEliteFitnessMin() {
		Double minFitness = null;

		// Request the elite fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(ELITE_FITNESSES);

		// Calculate the minimum fitness value.
		if (fitnesses != null) {
			minFitness = NumberUtils.min(fitnesses);
		}

		return minFitness;
	}

	/*
	 * Calculate and return the ELITE_FITNESS_MAX statistic.
	 */
	private Object getEliteFitnessMax() {
		Double maxFitness = null;

		// Request the elite fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(ELITE_FITNESSES);

		// Calculate the maximum fitness value.
		if (fitnesses != null) {
			maxFitness = NumberUtils.max(fitnesses);
		}

		return maxFitness;
	}

	/*
	 * Calculate and return the ELITE_FITNESS_AVE statistic.
	 */
	private Object getEliteFitnessAve() {
		Double aveFitness = null;

		// Request the elite fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(ELITE_FITNESSES);

		// Calculate the average fitness value.
		if (fitnesses != null) {
			aveFitness = StatsUtils.ave(fitnesses);
		}

		return aveFitness;
	}

	/*
	 * Calculate and return the ELITE_FITNESS_STDEV statistic.
	 */
	private Object getEliteFitnessStdev() {
		Double stdevFitness = null;

		// Request the elite fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(ELITE_FITNESSES);
		final double averageFitness = (Double) model.getStatsManager()
				.getStat(ELITE_FITNESS_AVE);

		// Calculate the standard deviation of the fitness values.
		if (fitnesses != null) {
			stdevFitness = StatsUtils.stdev(fitnesses, averageFitness);
		}

		return stdevFitness;
	}

	/*
	 * Calculate and return the ELITE_FITNESS_MEDIAN statistic.
	 */
	private Object getEliteFitnessMedian() {
		Double medianFitness = null;

		// Request the elite fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager()
				.getStat(ELITE_FITNESSES);

		// Calculate the median of the fitness values.
		if (fitnesses != null) {
			medianFitness = StatsUtils.median(fitnesses);
		}

		return medianFitness;
	}

	/*
	 * Calculate and return the ELITE_FITNESS_CI95 statistic.
	 */
	private Object getEliteFitnessCI95() {
		Double ci95Fitness = null;

		// Request the elite fitnesses from the stats manager.
		final double[] fitnesses = (double[]) model.getStatsManager().getStat(ELITE_FITNESSES);
		final double stdev = (Double) model.getStatsManager().getStat(ELITE_FITNESS_STDEV);

		// Calculate the 95% confidence interval from the mean of the fitness
		// values.
		if (fitnesses != null) {
			ci95Fitness = StatsUtils.ci95(fitnesses, stdev);
		}

		return ci95Fitness;
	}
}
