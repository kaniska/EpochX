/*
 * Copyright 2007-2010 Tom Castle & Lawrence Beadle
 * Licensed under GNU General Public License
 * 
 * This file is part of EpochX: genetic programming software for research
 * 
 * EpochX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * EpochX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with EpochX. If not, see <http://www.gnu.org/licenses/>.
 * 
 * The latest version is available from: http:/www.epochx.org
 */
package org.epochx.gp.stats;

import static org.epochx.gp.stats.GPStatField.*;
import static org.epochx.stats.StatField.GEN_POPULATION;

import java.util.List;

import org.apache.commons.lang.math.NumberUtils;
import org.epochx.gp.model.GPModel;
import org.epochx.gp.representation.GPCandidateProgram;
import org.epochx.stats.*;

/**
 * Generates statistics about evolutionary events within XGP.
 * 
 * <p>
 * A <code>StatsEngine</code> is plugged into <code>StatsManager</code>
 * instances to generate those statistics that are requested from the
 * <code>StatsManager</code>. When a statistic is calculated it may be dependant
 * upon other statistic fields which will be requested from the <code>
 * StatsManager</code> and may in turn be generated by this class.
 */
public class GPStatsEngine extends StatsEngine {

	// The controlling model.
	private final GPModel model;

	/**
	 * Constructs a <code>GPStatsEngine</code> to generate statistics on
	 * request.
	 * 
	 * @param model the Model which provides access to the <code>StatsManager
	 * </code>.
	 */
	public GPStatsEngine(final GPModel model) {
		super(model);

		this.model = model;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Object getGenerationStat(final String field) {
		Object value = super.getGenerationStat(field);

		if (value == null) {
			if (field.equals(GEN_DEPTHS)) {
				value = getGenDepths();
			} else if (field.equals(GEN_DEPTH_MIN)) {
				value = getGenDepthMin();
			} else if (field.equals(GEN_DEPTH_MAX)) {
				value = getGenDepthMax();
			} else if (field.equals(GEN_DEPTH_AVE)) {
				value = getGenDepthAve();
			} else if (field.equals(GEN_DEPTH_STDEV)) {
				value = getGenDepthStdev();
			} else if (field.equals(GEN_AVE_NODES_PER_DEPTH)) {
				value = getGenAveNodesPerDepth();
			} else if (field.equals(GEN_LENGTHS)) {
				value = getGenLengths();
			} else if (field.equals(GEN_LENGTH_MIN)) {
				value = getGenLengthMin();
			} else if (field.equals(GEN_LENGTH_MAX)) {
				value = getGenLengthMax();
			} else if (field.equals(GEN_LENGTH_AVE)) {
				value = getGenLengthAve();
			} else if (field.equals(GEN_LENGTH_STDEV)) {
				value = getGenLengthStdev();
			} else if (field.equals(GEN_NO_TERMINALS)) {
				value = getGenNoTerminals();
			} else if (field.equals(GEN_NO_TERMINALS_MIN)) {
				value = getGenNoTerminalsMin();
			} else if (field.equals(GEN_NO_TERMINALS_MAX)) {
				value = getGenNoTerminalsMax();
			} else if (field.equals(GEN_NO_TERMINALS_AVE)) {
				value = getGenNoTerminalsAve();
			} else if (field.equals(GEN_NO_TERMINALS_STDEV)) {
				value = getGenNoTerminalsStdev();
			} else if (field.equals(GEN_NO_DISTINCT_TERMINALS)) {
				value = getGenNoDistinctTerminals();
			} else if (field.equals(GEN_NO_DISTINCT_TERMINALS_MIN)) {
				value = getGenNoDistinctTerminalsMin();
			} else if (field.equals(GEN_NO_DISTINCT_TERMINALS_MAX)) {
				value = getGenNoDistinctTerminalsMax();
			} else if (field.equals(GEN_NO_DISTINCT_TERMINALS_AVE)) {
				value = getGenNoDistinctTerminalsAve();
			} else if (field.equals(GEN_NO_DISTINCT_TERMINALS_STDEV)) {
				value = getGenNoDistinctTerminalsStdev();
			} else if (field.equals(GEN_NO_FUNCTIONS)) {
				value = getGenNoFunctions();
			} else if (field.equals(GEN_NO_FUNCTIONS_MIN)) {
				value = getGenNoFunctionsMin();
			} else if (field.equals(GEN_NO_FUNCTIONS_MAX)) {
				value = getGenNoFunctionsMax();
			} else if (field.equals(GEN_NO_FUNCTIONS_AVE)) {
				value = getGenNoFunctionsAve();
			} else if (field.equals(GEN_NO_FUNCTIONS_STDEV)) {
				value = getGenNoFunctionsStdev();
			} else if (field.equals(GEN_NO_DISTINCT_FUNCTIONS)) {
				value = getGenNoDistinctFunctions();
			} else if (field.equals(GEN_NO_DISTINCT_FUNCTIONS_MIN)) {
				value = getGenNoDistinctFunctionsMin();
			} else if (field.equals(GEN_NO_DISTINCT_FUNCTIONS_MAX)) {
				value = getGenNoDistinctFunctionsMax();
			} else if (field.equals(GEN_NO_DISTINCT_FUNCTIONS_AVE)) {
				value = getGenNoDistinctFunctionsAve();
			} else if (field.equals(GEN_NO_DISTINCT_FUNCTIONS_STDEV)) {
				value = getGenNoDistinctFunctionsStdev();
			}
		}

		return value;
	}

	/*
	 * Calculate and return the GEN_DEPTHS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenDepths() {
		int[] depths = null;

		// Request the population from the stats manager.
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		// Get the depths of each program.
		if (pop != null) {
			depths = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				depths[i] = pop.get(i).getProgramDepth();
			}
		}

		return depths;
	}

	/*
	 * Calculate and return the GEN_DEPTH_MIN statistic.
	 */
	private Object getGenDepthMin() {
		Integer minDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getGenerationStat(
				GEN_DEPTHS);

		// Calculate the minimum depth.
		if (depths != null) {
			minDepth = NumberUtils.min(depths);
		}

		return minDepth;
	}

	/*
	 * Calculate and return the GEN_DEPTH_MAX statistic.
	 */
	private Object getGenDepthMax() {
		Integer maxDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getGenerationStat(
				GEN_DEPTHS);

		// Calculate the maximum depth.
		if (depths != null) {
			maxDepth = NumberUtils.max(depths);
		}

		return maxDepth;
	}

	/*
	 * Calculate and return the GEN_DEPTH_AVE statistic.
	 */
	private Object getGenDepthAve() {
		Double aveDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getGenerationStat(
				GEN_DEPTHS);

		// Calculate the average depth.
		if (depths != null) {
			aveDepth = StatsUtils.ave(depths);
		}

		return aveDepth;
	}

	/*
	 * Calculate and return the GEN_DEPTH_STDEV statistic.
	 */
	private Object getGenDepthStdev() {
		Double stdevDepth = null;

		// Request the population depths from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getGenerationStat(
				GEN_DEPTHS);

		// Calculate the standard deviation of the depths.
		if (depths != null) {
			stdevDepth = StatsUtils.stdev(depths);
		}

		return stdevDepth;
	}

	/*
	 * Calculate and return the GEN_AVE_NODES_PER_DEPTH statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenAveNodesPerDepth() {
		double[] aveNodes = null;

		// Request the dependant statistics from the stats manager.
		final int[] depths = (int[]) model.getStatsManager().getGenerationStat(
				GEN_DEPTHS);
		final int maxDepth = (Integer) model.getStatsManager()
				.getGenerationStat(GEN_DEPTH_MAX);
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		if (depths != null) {
			// Array to fill with average number of nodes at each depth.
			aveNodes = new double[maxDepth];

			// For each depth.
			for (int d = 0; d < maxDepth; d++) {
				// Get number of nodes for each program.
				final double[] noNodes = new double[pop.size()];
				for (int j = 0; j < pop.size(); j++) {
					noNodes[j] = pop.get(j).getNodesAtDepth(d).size();
				}
				aveNodes[d] = StatsUtils.ave(noNodes);
			}
		}

		return aveNodes;
	}

	/*
	 * Calculate and return the GEN_LENGTHS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenLengths() {
		int[] lengths = null;

		// Request the population from the stats manager.
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		// Get the lengths of each program.
		if (pop != null) {
			lengths = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				lengths[i] = pop.get(i).getProgramLength();
			}
		}

		return lengths;
	}

	/*
	 * Calculate and return the GEN_LENGTH_MIN statistic.
	 */
	private Object getGenLengthMin() {
		Integer minLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_LENGTHS);

		// Calculate the minimum length.
		if (lengths != null) {
			minLength = NumberUtils.min(lengths);
		}

		return minLength;
	}

	/*
	 * Calculate and return the GEN_LENGTH_MAX statistic.
	 */
	private Object getGenLengthMax() {
		Integer maxLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_LENGTHS);

		// Calculate the maximum length.
		if (lengths != null) {
			maxLength = NumberUtils.max(lengths);
		}

		return maxLength;
	}

	/*
	 * Calculate and return the GEN_LENGTH_AVE statistic.
	 */
	private Object getGenLengthAve() {
		Double aveLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_LENGTHS);

		// Calculate the average length.
		if (lengths != null) {
			aveLength = StatsUtils.ave(lengths);
		}

		return aveLength;
	}

	/*
	 * Calculate and return the GEN_LENGTH_STDEV statistic.
	 */
	private Object getGenLengthStdev() {
		Double stdevLength = null;

		// Request the population lengths from the stats manager.
		final int[] lengths = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_LENGTHS);

		// Calculate the standard deviation of the lengths.
		if (lengths != null) {
			stdevLength = StatsUtils.stdev(lengths);
		}

		return stdevLength;
	}

	/*
	 * Calculate and return the GEN_NO_TERMINALS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenNoTerminals() {
		int[] noTerminals = null;

		// Request the population from the stats manager.
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		// Get the number of terminals of each program.
		if (pop != null) {
			noTerminals = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				noTerminals[i] = pop.get(i).getNoTerminals();
			}
		}

		return noTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_TERMINALS_MIN statistic.
	 */
	private Object getGenNoTerminalsMin() {
		Integer minNoTerminals = null;

		// Request the population's number of terminals from the stats manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_TERMINALS);

		// Calculate the minimum number of terminals.
		if (noTerminals != null) {
			minNoTerminals = NumberUtils.min(noTerminals);
		}

		return minNoTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_TERMINALS_MAX statistic.
	 */
	private Object getGenNoTerminalsMax() {
		Integer maxNoTerminals = null;

		// Request the population's number of terminals from the stats manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_TERMINALS);

		// Calculate the maximum number of terminals.
		if (noTerminals != null) {
			maxNoTerminals = NumberUtils.max(noTerminals);
		}

		return maxNoTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_TERMINALS_AVE statistic.
	 */
	private Object getGenNoTerminalsAve() {
		Double aveNoTerminals = null;

		// Request the population's number of terminals from the stats manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_TERMINALS);

		// Calculate the average number of terminals.
		if (noTerminals != null) {
			aveNoTerminals = StatsUtils.ave(noTerminals);
		}

		return aveNoTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_TERMINALS_STDEV statistic.
	 */
	private Object getGenNoTerminalsStdev() {
		Double stdevNoTerminals = null;

		// Request the population's number of terminals from the stats manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_TERMINALS);

		// Calculate the standard deviation of the number of terminals.
		if (noTerminals != null) {
			stdevNoTerminals = StatsUtils.stdev(noTerminals);
		}

		return stdevNoTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_TERMINALS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenNoDistinctTerminals() {
		int[] noDistinctTerminals = null;

		// Request the population from the stats manager.
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		// Get the number of unique terminals of each program.
		if (pop != null) {
			noDistinctTerminals = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				noDistinctTerminals[i] = pop.get(i).getNoDistinctTerminals();
			}
		}

		return noDistinctTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_TERMINALS_MIN statistic.
	 */
	private Object getGenNoDistinctTerminalsMin() {
		Integer minNoDistinctTerminals = null;

		// Request the population's number of distinct terminals from the stats
		// manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_TERMINALS);

		// Calculate the minimum number of unique terminals.
		if (noTerminals != null) {
			minNoDistinctTerminals = NumberUtils.min(noTerminals);
		}

		return minNoDistinctTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_TERMINALS_MAX statistic.
	 */
	private Object getGenNoDistinctTerminalsMax() {
		Integer maxNoDistinctTerminals = null;

		// Request the population's number of distinct terminals from the stats
		// manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_TERMINALS);

		// Calculate the maximum number of unique terminals.
		if (noTerminals != null) {
			maxNoDistinctTerminals = NumberUtils.max(noTerminals);
		}

		return maxNoDistinctTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_TERMINALS_AVE statistic.
	 */
	private Object getGenNoDistinctTerminalsAve() {
		Double aveNoDistinctTerminals = null;

		// Request the population's number of distinct terminals from the stats
		// manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_TERMINALS);

		// Calculate the average number of unique terminals.
		if (noTerminals != null) {
			aveNoDistinctTerminals = StatsUtils.ave(noTerminals);
		}

		return aveNoDistinctTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_TERMINALS_STDEV statistic.
	 */
	private Object getGenNoDistinctTerminalsStdev() {
		Double stdevNoDistinctTerminals = null;

		// Request the population's number of distinct terminals from the stats
		// manager.
		final int[] noTerminals = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_TERMINALS);

		// Calculate the standard deviation of the number of unique terminals.
		if (noTerminals != null) {
			stdevNoDistinctTerminals = StatsUtils.stdev(noTerminals);
		}

		return stdevNoDistinctTerminals;
	}

	/*
	 * Calculate and return the GEN_NO_FUNCTIONS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenNoFunctions() {
		int[] noFunctions = null;

		// Request the population from the stats manager.
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		// Get the number of functions of each program.
		if (pop != null) {
			noFunctions = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				noFunctions[i] = pop.get(i).getNoFunctions();
			}
		}

		return noFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_FUNCTIONS_MIN statistic.
	 */
	private Object getGenNoFunctionsMin() {
		Integer minNoFunctions = null;

		// Request the population's number of functions from the stats manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_FUNCTIONS);

		// Calculate the minimum number of functions.
		if (noFunctions != null) {
			minNoFunctions = NumberUtils.min(noFunctions);
		}

		return minNoFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_FUNCTIONS_MAX statistic.
	 */
	private Object getGenNoFunctionsMax() {
		Integer maxNoFunctions = null;

		// Request the population's number of functions from the stats manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_FUNCTIONS);

		// Calculate the maximum number of functions.
		if (noFunctions != null) {
			maxNoFunctions = NumberUtils.max(noFunctions);
		}

		return maxNoFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_FUNCTIONS_AVE statistic.
	 */
	private Object getGenNoFunctionsAve() {
		Double aveNoFunctions = null;

		// Request the population's number of functions from the stats manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_FUNCTIONS);

		// Calculate the average number of functions.
		if (noFunctions != null) {
			aveNoFunctions = StatsUtils.ave(noFunctions);
		}

		return aveNoFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_FUNCTIONS_STDEV statistic.
	 */
	private Object getGenNoFunctionsStdev() {
		Double stdevNoFunctions = null;

		// Request the population's number of functions from the stats manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_FUNCTIONS);

		// Calculate the standard deviation of the number of functions.
		if (noFunctions != null) {
			stdevNoFunctions = StatsUtils.stdev(noFunctions);
		}

		return stdevNoFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_FUNCTIONS statistic.
	 */
	@SuppressWarnings("unchecked")
	private Object getGenNoDistinctFunctions() {
		int[] noDistinctFunctions = null;

		// Request the population from the stats manager.
		final List<GPCandidateProgram> pop = (List<GPCandidateProgram>) model
				.getStatsManager().getGenerationStat(GEN_POPULATION);

		// Get the number of unique functions of each program.
		if (pop != null) {
			noDistinctFunctions = new int[pop.size()];

			for (int i = 0; i < pop.size(); i++) {
				noDistinctFunctions[i] = pop.get(i).getNoDistinctFunctions();
			}
		}

		return noDistinctFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_FUNCTIONS_MIN statistic.
	 */
	private Object getGenNoDistinctFunctionsMin() {
		Integer minNoDistinctFunctions = null;

		// Request the population's number of distinct functions from the stats
		// manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_FUNCTIONS);

		// Calculate the minimum number of unique functions.
		if (noFunctions != null) {
			minNoDistinctFunctions = NumberUtils.min(noFunctions);
		}

		return minNoDistinctFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_FUNCTIONS_MAX statistic.
	 */
	private Object getGenNoDistinctFunctionsMax() {
		Integer maxNoDistinctFunctions = null;

		// Request the population's number of distinct functions from the stats
		// manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_FUNCTIONS);

		// Calculate the maximum number of unique functions.
		if (noFunctions != null) {
			maxNoDistinctFunctions = NumberUtils.max(noFunctions);
		}

		return maxNoDistinctFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_FUNCTIONS_AVE statistic.
	 */
	private Object getGenNoDistinctFunctionsAve() {
		Double aveNoDistinctFunctions = null;

		// Request the population's number of distinct functions from the stats
		// manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_FUNCTIONS);

		// Calculate the average number of unique functions.
		if (noFunctions != null) {
			aveNoDistinctFunctions = StatsUtils.ave(noFunctions);
		}

		return aveNoDistinctFunctions;
	}

	/*
	 * Calculate and return the GEN_NO_DISTINCT_FUNCTIONS_STDEV statistic.
	 */
	private Object getGenNoDistinctFunctionsStdev() {
		Double stdevNoDistinctFunctions = null;

		// Request the population's number of distinct functions from the stats
		// manager.
		final int[] noFunctions = (int[]) model.getStatsManager()
				.getGenerationStat(GEN_NO_DISTINCT_FUNCTIONS);

		// Calculate the standard deviation of the number of unique functions.
		if (noFunctions != null) {
			stdevNoDistinctFunctions = StatsUtils.stdev(noFunctions);
		}

		return stdevNoDistinctFunctions;
	}
}
